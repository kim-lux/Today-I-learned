linux Command
mkdir <file name> => 해당 위치에 <<file name>을 가진 폴더를 만듦
pwd => 자신의 위치를 알려줌
clear => 화면의 log를 지워줌
touch <file name> => 빈 파일을 만들어줌
cat <file name> =>  파일 한 개 이상의 내용을 화면에 출력할때 사용
cd .. => 상위 dir로 넘어감
cp <file name1> <file name2> => 파일 이름 1을 파일 이름 2로 Copy함.
mv <file name1> <file name2> => 파일 이름을 1에서 2로 바꾸어 줌.
rm <file name> => 파일을 삭제함
whoami => root dir을 알려줌
ls *.txt => all이라는 와일드 카드를 사용하여 해당 확장자를 가진 파일들 을 보여줌.
rmdir <dir name> => dir을 지우는데 안에 있는 파일이 전부 지워져 있어야함.

---------------------------------------------------------------
vi 사용법

vi <file name> => vi 문서 편집기를 열어줌.
*************************************명령어 모드*************************************
1.1 초기 명령어 모드에서 "i"(insert) 명령어를 통해서 입력모드로 갈 수 있다.
1.2 초기 명령어 모드에서 "a"(append) 명령어를 통해서 입력모드로 갈 수 있다.
2 현재의 HJKL을 통해 위치를 이동할 수 있음
3.1 "w" 를 통해 한 단어씩 앞으로 이동할 수 있음 ([n]w 으로도 사용가능)
3.2 "b" 를 통해 한 단어씩 뒤으로 이동할 수 있음 ([n]b 으로도 사용가능)
4 "x"를 누르면 하나의 글자를 삭제함. ([n]x 으로도 사용가능)
5.1 "dw"를 누르면 뒤쪽으로 한단어를 삭제함. ([n]dw 으로도 사용가능)
5.2 "db"를 누르면 앞쪽으로 한단어를 삭제함. ([n]db 으로도 사용가능)
6. "dd"를 누르면 앞쪽으로 한줄을 삭제함. ([n]dd 으로도 사용가능)
7. "u" 이전 명령어 취소 (되돌리기 = Ctrl+z)
8.0 "y" 커서 범위 복사
8.1 "yw" 한 단어 복사 ([n]yw 으로도 사용가능)
8.2 "yy" 한 줄 복사 ([n]yy 으로도 사용가능)
9. "p" 한 단어/줄 붙여넣기
10. "v" 비주얼하게 커서를 보여줘서 HJKL로 커서를 확장하거나 줄일 수 있음
11. "/ + <찾고자하는 글자>" 찾고 싶은 글자를 찾아주고 "n"을 통해서 다음 걸로 넘어 갈 수 있다.
12 ":w" write Update
13 ":q" quit
13 ":s" subtitution ex) :s/kim/Lee => Kim을 Lee로 한변에 변환


*************************************입력 모드*************************************
1. ESC를 통해서 명령어 모드로 전환할 수 있다.
2. 명령어 모드에서 "i" 나 "a" 명령을 통해서 입력모드로 넘어 갈 수 있고 입력 모드로 가게 되면 자유로롭게 코드를 작성할 수 있다.

*************************************마지막 행 모드*************************************
1. 명령어 모드에서 ":" (콜론) 을 입력하면 화면 맨 밑단에 입력을 할수 있는 공간이 나오다. 여기서 현재까지 내가 작성한 이 내용을 저장하고 vi를 종료할지 그냥 종료할지 등을 입력할 수 있다.

---------------------------------------------------------------------
gcc a.c => 컴파일 후 실행파일을 만듦
gcc -c a.c => 컴파일만 함/ ".o" (object 파일)을 만들게 됨. / link를 하지 않음
gcc a.o => object파일로 실행파일로 만듦.(Link 작업을 함)

Ex) 
add.c => int main() 이 없는 파일, int add (int, int) 가 있음
main.c => int main() 이 있는 파일, add를 사용함, 상단에 int add (int, int)를 선언해줌
이 존재할 때
단독으로 gcc add.c를 하면 오류가 생김
1. gcc add.c main.c 로 컴파일을 하면 a.out이라는 실행파일이 생성되게 됨

혹은

2.1 gcc -c add.c / gcc -c main.c 를 하게 되면 add.o 파일과 main.o 파일이 생성
2.2 gcc add.o main.o 를 하게 되면 a.out이라는 실행파일이 생성되게 됨

=> 나눠서 gcc -c 하는 이유 : 수정한 파일만 컴파일을 해주고 새로 수정한 것만 합쳐서 .o 파일을 gcc 해주면 Linking을 해주면 컴파일 시간이 줄어들기 때문
=> makefile이 있는 이유 : 수정한 것만 알아서 보고 컴파일 해주기 위해서
./a.out => 실행 파일을 실행
