whami : 현재 user가 누구인지 출력
adduser <user name> : 새로운 User(ID)를 만듦
su <user name> : 해당 User로 변경


ls 
-a : 숨겨져 있는 파일들을 탐색
-l : 자세한 정보를 얻고 싶을 때

*ls 명령어 같은 것들은 system Call을 사용해서 구현이 되어 있다.

int main(int argc, char *argv[])
argc : argument의 개수 ./a.out 포함
argv[x] : argument의 내용 ./a.out 포함


*File Vs Dir

Dir : file들의 정보를 가지고 있는 file이다.
file system은 대부분 tree 구조이다
directory : file name과 file location을 함께 가지고 있다. (inode number + file number)
하나의 같은 파일을 가르키는 여러개의 파일이름을 가질 수 있다

* inode
각 파일은 inode 값을 가지고 있다
data block을 찾아 갈 수 있는 pointer 값을 저장하고 있다.
file 상태정보를 가지고 있다.


Dir 읽는 코드 작성(opendir, readdir)

*chmod
mod  = file type + permission
리눅스에서는 어떻게 file에 대한 접근 권한을 관리하느냐
user/group/모든사람
r : 읽기 권한
w : 쓰기 권한
x : 실행 권한

chmod를 통해서 권한 변경 가능 

--------------------------ls1.c-----------------------------------
#include <stdio.h>
#include <string.h>
#include <sys/types.h>
#include <dirent.h>
#include <sys/stat.h>
#include <stddef.h>
void do_ls(char[]);
void dostat(char*);
void show_file_info(char*, struct stat*);
void mode_to_letters(int, char[]);
char* uid_to_name(uid_t);
char* gid_to_name(gid_t);

int main(int argc, char* argv[])
{
	  if(argc == 1)
	  {
		  do_ls(".");
	  }
	  else
	  {
	 	 while(--argc)
	         {
			 printf("%s:\n", *++argv);
			 do_ls(*argv);
		 }
	  }
}

void do_ls(char dirname[])
{
	  DIR* dir_ptr;
	  struct dirent* direntp;
	  if((dir_ptr = opendir(dirname))==NULL)
	  	fprintf(stderr,"ls2: cannot open %s\n", dirname);
	  else
	  {
	 	 while((direntp = readdir(dir_ptr)) != NULL)
		 dostat(direntp->d_name);
	         closedir(dir_ptr);
	  }
}
void dostat (char *filename)
{
	  struct stat info;
	  if(stat(filename, &info) == -1)
	  	perror(filename);
	  else
 	  	show_file_info(filename, &info);
}

void show_file_info(char* filename, struct stat* info_p)
{
	  char *uid_to_name(), *ctime(), *gid_to_name(), *filemode();
	    void mode_to_letters();
	      char modestr[20];

	        mode_to_letters(info_p->st_mode, modestr);
		  printf("%s ",modestr);
		    printf("%4d ",(int)info_p->st_nlink);
		      printf("%-8s ",uid_to_name(info_p->st_uid));
		        printf("%-8s ",gid_to_name(info_p->st_gid));
			  printf("%-8ld ",(long)info_p->st_size);
			    printf("%.12s  ",4+ctime(&info_p->st_mtime));
			      printf("%s \n",filename);  

			        
}

void mode_to_letters(int mode, char str[])
{
	  strcpy(str,"-------------");
	    if(S_ISDIR(mode)) str[0] = 'd';
	    if(S_ISCHR(mode)) str[0] = 'c';
		if(S_ISBLK(mode)) str[0] = 'd';

		if(mode & S_IRUSR) str[1] = 'r';
		if(mode & S_IWUSR) str[2] = 'w';
		if(mode & S_IXUSR) str[3] = 'x';
		        
        if(mode & S_IRGRP) str[4] = 'r';
	    if(mode & S_IWGRP) str[5] = 'w';
	    if(mode & S_IXGRP) str[6] = 'x';

		if(mode & S_IROTH) str[7] = 'r';
		if(mode & S_IWOTH) str[8] = 'w';
		if(mode & S_IXOTH) str[9] = 'x';

}
#include<pwd.h>
char* uid_to_name(uid_t uid)
{
	  struct passwd *getpwuid(), *pw_ptr;
	  static char numstr[10];

	  if((pw_ptr=getpwuid(uid)) == NULL)
	  {
	  	sprintf(numstr,"%d",uid);
	        return numstr;
       	  }
	  else
	  	return pw_ptr->pw_name;
}
#include<grp.h>
char* gid_to_name(gid_t gid)
{
	  struct group *getgrid(), *grp_ptr;
	  static char numstr[10];
	  if((grp_ptr = getgrgid(gid)) == NULL)
	  {
	 	 sprintf(numstr, "%d",gid);
	         return numstr;
	  }
	  else
		 return grp_ptr->gr_name;
}


