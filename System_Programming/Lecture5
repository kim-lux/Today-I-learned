*링크를 거는 방법 2가지 / 바로가기에 해당하는 명령어이다.

 1. ln a.c c.c : a.c파일을 수정하면 c.c파일도 동일하게 수정이 된다. => inode도 같음 / 물리적으로 같은 파일이다 

 2. ln -s a.c c.c :  a.c파일을 수정하면 c.c파일도 동일하게 수정이 된다. => 단순히 링크만 걸어줌(심볼릭 링크) / inode는 다름


*find 명령어

find . -name "signal.h" -print : 현재 dir에서 "signal.h" 을 find 함

*grep 명령어

grep ifdef signal.h 
: signal.h에서 "ifdef" 라는 문자열이 있는지 찾아줌

grep ifdef *.h | more 
: *.h에서 "ifdef" 라는 문자열이 있는지 찾아줌 /  한페이지 단위로

grep SIGNAL *.h 
: 현재 *dir에서 .h 라는 이름을 가진 파일 중에 SIGNAL이 어디 있는지

*find & grep 명령어

find . -name "*.h" -exec grep SIGNAL {} /dev/null \; 
: 현재 dir *이외에 안까지 SIGNAL이 란 것을 찾음

*file System

리눅스에서 파일은 superblock + inode table + data area 로 나누어 관리 된다.

모든 파일은 inode를 가지는데 파일의 데이터가 하드디스크의 어느 곳에 저장되어 있는지(어느 데이터 블록을 사용하는지) list로 관리하여 알려준다.

ls -i 옵션을 통해 inode를 알 수 있다.

파일을 삭제할 때는 inode 데이터만 지우는 것이라서 물리적인 데이터는 남아있어서 복구가 가능하다.





 write root /dev/pts/7

control c 개념 /signal?

ps -aux | grep sig

kill -2 6654 => 특정프로세서 한테 2번을 보냄 /9번을 보내면 죽음

kill 6654 => 그냥 죽일 수도 있음 

시그널은 software Interrupt이다. 비동기적으로 발생하고 유닉스 운영체제가 프로세스에 전달한다.
Signal은 다음과 같은 3가지 경우에 발생한다.
1. 0으로 나누기 처럼 프로그램에서 예외적인 상황이 일어나는 경우
2. Process가 Kill 함수와 같이 시그널을 보낼 수 있는 함수를 사용해 다른 프로세스에 시그널을 보내는 경우
3. 사용자가 [Ctrl] + [C] 같은 인터럽트 키를 입력한 경우
