*링크를 거는 방법 2가지 / 바로가기에 해당하는 명령어이다.

 1. ln a.c c.c : a.c파일을 수정하면 c.c파일도 동일하게 수정이 된다. => inode도 같음 / 물리적으로 같은 파일이다 
 
 Hard link
-inode 안에는 hard link의 갯수도 포함되어 있다. (즉, hard link라도 여러개일수 있다.)
-rm 혹은 unlink로 hard link를 지울 수 있고, hard link 숫자가 0이 되면 파일의 inode는 사라진다.
-여러개가 하나의 file에 연결된 경우, 하나만 바꿔줘도 file data가 바뀐다.
-동일한 file system안에 있는 파일끼리만 hard link가 가능하다.

 2. ln -s a.c c.c :  a.c파일을 수정하면 c.c파일도 동일하게 수정이 된다. => 단순히 링크만 걸어줌(심볼릭 링크) / inode는 다름
 
 Symbolic link 
-다른 파일이나 디렉토리의 이름을 가지고 있는 특별한 타입의 파일
-간접적으로 원본의 path를 가지고 있는 것
-inode의 데이터블록에 다른 파일 혹은 디렉토리의 경로를 가지고 있다.

*find 명령어

find . -name "signal.h" -print : 현재 dir에서 "signal.h" 을 find 함

*grep 명령어

grep ifdef signal.h 
: signal.h에서 "ifdef" 라는 문자열이 있는지 찾아줌

*find & grep 명령어

find . -name "*.h" -exec grep SIGNAL {} /dev/null \; 
: 현재 dir *이외에 안까지 SIGNAL이 란 것을 찾음

*file System

리눅스에서 파일은 superblock + inode table + data area 로 나누어 관리 된다.

모든 파일은 inode를 가지는데 파일의 데이터가 하드디스크의 어느 곳에 저장되어 있는지(어느 데이터 블록을 사용하는지) list로 관리하여 알려준다.

ls -i 옵션을 통해 inode를 알 수 있다.

파일을 삭제할 때는 inode 데이터만 지우는 것이라서 물리적인 데이터는 남아있어서 복구가 가능하다.


* tty : 이 터미널이 어떤 file에 연결 되어 있는지 확인

 write root /dev/pts/7 : 7번 터미널에 연결해서 쓸 수 있음
=> 터미널/ 디바이스들이 파일 형식으로 read/write 되고 있음


* signal_handling
result = signal(int signum, void(*action)(int)) => argu가 int 하나이고 return이 void 인 함수
ps -aux | grep sig

kill -2 6654 => 특정프로세서 한테 2번을 보냄 /9번을 보내면 죽음

kill 6654 => 그냥 죽일 수도 있음 

* 시그널은 software Interrupt이다. 비동기적으로 발생하고 유닉스 운영체제가 프로세스에 전달한다.
Signal은 다음과 같은 3가지 경우에 발생한다.
1. 0으로 나누기 처럼 프로그램에서 예외적인 상황이 일어나는 경우
2. Process가 Kill 함수와 같이 시그널을 보낼 수 있는 함수를 사용해 다른 프로세스에 시그널을 보내는 경우
3. 사용자가 [Ctrl] + [C] 같은 인터럽트 키를 입력한 경우
